# <font style="color:rgb(38, 218, 38);">完成事项</font>

接着上期的汇编寄存器还有一部分没说完

3.1 指针寄存器

### 3. 指针寄存器

1. **SP - 堆栈指针寄存器**

* **作用**：始终指向**堆栈的顶部**
    push ax     ; SP = SP - 2（16位）
    pop bx      ; SP = SP + 2（16位）

**应用**：

* 函数调用时的参数传递

* 局部变量存储

* 保存寄存器状态

### 2. **BP - 基址指针寄存器**

* **作用**：用于**访问栈帧中的数据**

* **特点**：通常与 SP 配合使用
    ; 假设调用：func(10, 20)
    func proc
  
        push bp
        mov bp, sp
        mov ax, [bp+4]   ; 获取第一个参数
        mov bx, [bp+6]   ; 获取第二个参数
        pop bp
        ret
  
    func endp
    func endp 是 汇编语言中的伪指令，用于标记一个过程的结束
    函数名 proc   ; 过程（函数）的开始
  
        ...      ; 函数体代码
  
    函数名 endp   ; 过程（函数）的结束

### 3. **SI - 源变址寄存器**

* **作用**：在字符串/数据块操作中作为**源地址指针**
    mov si, offset source  ; SI 指向源数据
    mov cx, 10             ; 复制10个字节
    rep movsb              ; 从[SI]复制到[DI]

### 4. **DI - 目的变址寄存器**

* **作用**：在字符串/数据块操作中作为**目的地址指针**
    mov di, offset dest    ; DI 指向目标缓冲区
  
                           ; 与 SI 配合进行数据移动

### 5. **IP - 指令指针寄存器**

* **作用**：指向**下一条要执行的指令**
- 特点：
  
  * **不能直接修改**（不像其他寄存器可以用 MOV 指令）
  
  * 只能通过控制转移指令间接修改
  
  * 自动递增（根据指令长度）

# 寻址方式

### 定义：指令中用于说明如何寻找操作数的方法

    MOV    AX,      2000H
        目的操作数   源操作数

# 分类

- 立即寻址                 MOV AX,3000H       

- 寄存器寻址             MOV AX,BX

- 间接寻址                 MOV AX,[2000H]

- 寄存器间寻址         MOV AX,[BX]

- 变址寻址                 MOV AX,[BX+2000H]  

- 基址加变址寻址     MOV AX,[SI+BX+2000H]          [SI+BX]单独两个寄存器也算
  
  

- 将 *3000H* 的值赋给 *AX*

- 将 *寄存器BX* 的值赋值给 *AX*

- 将 *地址[2000X]处* 的值赋给 *AX*

- 将 *通过寄存器BX的值找到内存地址位置* 的值赋给 *AX*

- 将 *3000H* 的值赋给 *AX*

- 将两个 *单独两个寄存器中的值或再加上另外的值* 所得出的结果就是源操作数的地址



(https://img.cdn1.vip/i/6987ec26ec4ca_1770515494.webp)


## 关于寻址方式实际的应用：

将datasg段中的每个单词的头一个字母改为大写字母

（只是对照代码分析）

    assume cs:codesg,ds:datasg
    datasg segment
        db'1.file     '
        db'2.esit     '
        db'3.search     '
        db'4.view     '
        db'5.options     '
        db'6.help     '
    datasg ends
    
    codesg segment
     start:....
       mov 4c00h
       int 21h
    codesg ends
    end start

   0      1     2     3     4     5     6     7     8     9     A     B     C     D     E     F  （16进制还有个空格）

00       1            f      i       l      e

10       2            e    d      i       t

20       3            s      e     a     r     c     h

30       4            v      i      e     w

40       5            o     p      t      i      o    n      s

50       6            h      e     l       p

             datasg中的数据存贮结构

思路：通过一个寄存器存入第一行首个元素的地址，之后通过循环累加16（因为16进制）到下一行的首字母

- 通过 *寄存器相对寻址*  [bx+idata]的方式
  
  - 设 R=第一行地址
  
  -     mov cx，6            ；循环6次
  
  - 以下为循环内过程 
    
    - 改变R行三列的字母为大写
    
    - R=下一行的地址

#### 

#### 带入上述例子：

      mov ax,datasg
      mov ds,ax
    
      mov bx,0              ；R取到第一行
      mov cx,6              ；设置六次循环
    s:mov al,[bx+3]         ；取到第一行的第三位也就是f的位置，将f放到al中
      and al,11011111b      ；将al中的f转大写
      mov [bx+3],al         ；再将al放回[bx+3]的位置，也就是从新放回去
      add bx,16             ；bx加16位，到下一行
      loops

- 以此循环6次便可将上述所有首字母变为大写



### 补充一下汇编指令的图方便理解

(https://img.cdn1.vip/i/6987ec5655221_1770515542.webp)


# CPU的组成

![01506fd4-0392-4ea4-b3b6-661b106e0edb](https://img.cdn1.vip/i/6987ec780f68c_1770515576.webp)


- CUP在工作时
  
  - 通过BUS的总线连接内存空间，进行内存交互
  
  - 运算器进行信息处理（ALU）
  
  - 寄存器进行信息存储
  
  - 控制器协调各个器件进行工作(EU Control Logic 和Bus Control Logic)

### 物理地址

下图对应的8086

![57a3cd77-b065-44ba-a452-30735cfd986c](https://img.cdn1.vip/i/6987ec94a13c0_1770515604.webp)


- CPU访问内存单元时要给出内存单元的地址

- 所有的内存单元构成的存储空间是一个一维的线性空间

- 每一个内存单元在这个空间中都有唯一的地址，这个唯一的地址称为 *物理地址*



##### 8086有20位地址总线，可传送20位地址，寻址能力为1M

##### 8086是16位CUP

- 运算器一次最多可以处理16位的数据，寄存器的最大宽度为16位

- 在8086内部处理的、传输、暂存的地址也是16位，寻址能力只有64KB

## 这寻址空间是存在空间大小差异的

8086给出的解决方法：

将下图蓝色部分的寄存器中16位的数据传到位址加法器中进行运算

![5ed831fd-6453-476d-9205-b0103cf63a9b](https://img.cdn1.vip/i/6987eca38b4da_1770515619.webp)


- 通过用两个16位地址（段地址，偏移地址）合成一个20位的物理地址。

- 物理地址=段地址×16＋偏移地址

![1e559143-f988-4ff6-8d73-1404a0463983](https://img.cdn1.vip/i/6987ecc06b0da_1770515648.webp)


例子：

       段地址： 1230
    ＋偏移地址：  00C8
    -----------------------
       物理地址：123C8

##### 关于段地址是否唯一

段地址可以通过多种方式来与偏移地址组成物理地址

       段地址： 123C0
    ＋偏移地址：  0008
    -----------------------
       物理地址：123C8

- 将段地址改为123C偏移地址位0008运算后同样能得到对应的物理地址

不但可以改变一个数，还能将单独的数拆开

       段地址： 123B
    ＋偏移地址：  0018
    -----------------------
       物理地址：123C8

如将16位的C可以拆成B和1分别放置于段地址和偏移地址中，预算后仍然可以得到正确的物理地址
