# <font style="color:rgb(138, 238, 38);">完成事项</font>

+ 基于Primer Plus中前4章节的知识点对c语言中的基础知识进行学习
  
  # <font style="color:rgb(138, 38, 38);">下周待做事项</font>

+ 将基础知识完善，进入到编程阶段

# <font style="color:rgb(38, 38, 338);">本周学习的知识分享（由于是基础知识，就对自我学习中存在较大问题的地方，或是基础架构进行记录分析）</font>

# 1.基础数据类型（在《Primer Plus》 p43处存在的问题）

- int类型（其中存在signed int 与unsigned int）：int类型是有符号整形，可为正负整数，或0。其取值范围就计算机不同而异。其中在不同整形之间转换时需注意以下几点：
  
  ### <font style="color:rgb(138, 208, 538);">1：无符号类型转化为有符号类型时：数值”溢出“变为负数</font>
  
  具体说明：由于在计算机中数据都是以二进制的方式存储，而有符号为需要用第一位来表示数值的正负，又因无符号与有符号在相同环境下占用位数相同，所以无符号位的最大值一定要比有符号位的最大值大1，故当大于有符号位的无符号位向有符号位转换时输出结果将会变为-1
  
  ```整数溢出
  #include <stdio.h>
  int main() {
      unsigned int a = 2000000000;  // 无符号32位，值为20亿（二进制最高位为0）
      unsigned int b = 3000000000;  // 无符号32位，值为30亿（二进制最高位为1）
      int c = a;  // 转换后c=2000000000（正常）
      int d = b;  // 转换后d=-1294967296（溢出变负）
      printf("%d\n", d);  // 输出结果：-1294967296
      return 0;
  }
  ```
  
   <font style="color:rgb(38, 38, 38);">本周学习总结</font>

- 在上述程序中分两步进行从b到d的转化

- 一,先将b的数值转化为32位二进制数10110011101011001010010100000000（补码）

- 二,对补码进行解读
  
  1. **求反码**（符号位不变，数值位按位取反）：`11001100010100110101101011111111`
  2. **求原码**（反码 + 1）：`11001100010100110101101100000000`
  3. **计算数值**：原码的数值位（后 31 位）对应的十进制为`1294967296`，加上符号位的负号，结果为`-1294967296`。

- ### <font style="color:rgb(138, 208, 538);">2. 有符号类型转换为无符号类型：负数 “变” 大正数</font>

- 有符号负数转换为同长度的无符号类型时，符号位被当作数值位，结果会变成一个很大的正数（补码的无符号解读）。

- 无符号解读是**强行将这段二进制视为无符号数**（最高位不再是符号位，而是普通数值位，取值范围 `0 ~ 2^n - 1`，n 为总位数）。

- ### 关键规律：补码与无符号解读的数值对应关系
  
  对于 n 位二进制（以 8 位为例），补码的无符号解读值遵循以下规律：
  1-------若补码最高位为 0（正数）：无符号解读值 = 补码本身的数值（因为正数补码 = 原码，最高位 0 不影响数值）。例：补码 `00000101`（+5）→ 无符号解读为 `5`。
  2-------若补码最高位为 1（负数）：无符号解读值 = 补码对应的 “无符号数” = `2^n + 补码的有符号值`。例：8 位补码 `11111111` 是 `-1`（有符号），无符号解读为 `2^8 + (-1) = 255`；8 位补码 `10000000` 是 `-128`（有符号），无符号解读为 `256 + (-128) = 128`。
  
  ```补码的无符号解读
  int a = -1;          // 32位补码：11111111 11111111 11111111 11111111
  unsigned int b = a;  // 对上述补码做无符号解读：2^32 - 1 = 4294967295
  printf("%u", b);     // 输出：4294967295
  ```

### <font style="color:rgb(138, 208, 538);">3.长字节类型转短字节类型：高位截断导致值异常</font>

- 当长字节类型（如 `int`，4 字节）转换为短字节类型（如 `char`，1 字节）时，会截断高位字节，仅保留低位，导致值与原数值差异极大。

- ```截断实例
  int a = 300;  // 4字节二进制：00000000 00000000 00000001 00101100
  char c = a;   // 截断为1字节（仅保留低位）：00101100 → 十进制44（与300完全不同）
  ```

### <font style="color:rgb(138, 208, 538);">4. 短字节有符号类型转长字节类型：符号扩展导致 “意外大值”</font>

短字节有符号类型（如 `signed char`）转换为长字节类型（如 `int`）时，会进行**符号扩展**<font style="color:rgb(138, 208, 38);">（高位填充符号位）</font>。若原数是负数，扩展后可能变成一个绝对值很大的负数（或被误解读为无符号大正数）。

```实例
signed char c = 0x80;  // 1字节有符号数，二进制10000000（补码表示-128）
int i = c;             // 符号扩展为4字节：11111111 11111111 11111111 10000000 → 仍为-128（正确）

// 若转换为无符号长类型：
unsigned int u = c;    // 符号扩展后的二进制被解读为无符号数 → 4294967168（极大值）
```

### <font style="color:rgb(138, 208, 538);">5. 不同长度无符号类型转换：高位填充 0 导致 “值不变” 的假象 </font>

短字节无符号类型（如 `unsigned char`）转换为长字节无符号类型（如 `unsigned int`）时，高位填充 0，值看似不变，但需注意：若原数在短类型中是最大值（如 `255`），转换为长类型后仍是 `255`（而非长类型的最大值）。

```案例
unsigned char uc = 255;  // 1字节无符号最大值
unsigned int ui = uc;    // 扩展为4字节：00000000 00000000 00000000 11111111 → 仍为255
```

### <font style="color:rgb(138, 208, 538);"> 6. 混合运算中的隐式转换：逻辑错误 </font>

当有符号和无符号类型混合运算时，C 语言会**隐式将有符号类型转换为无符号类型**，可能导致反直觉的结果。

```案例
int a = -1;
unsigned int b = 1;
if (a > b) {  // 实际执行：(unsigned int)-1 > 1 → 4294967295 > 1 → 条件为真
    printf("a > b");  // 被执行，显然不符合直观逻辑
}
```

### 如何避免这些问题？

1. **明确类型匹配**：转换时确保源类型的数值在目标类型的表示范围内（如无符号类型只存非负数）。
2. **避免混合有符号和无符号运算**：若必须混合，显式转换为同类型（如 `(long)a > (long)b`）。
3. **使用显式类型转换**：通过 `(目标类型)` 明确转换意图，避免隐式转换的隐蔽错误。
4. **利用 `typedef` 统一类型**：定义别名（如 `typedef int32_t Int32`），减少不同长度类型的混用

# 基础循环语句

### <font style="color:rgb(138, 208, 538);">1.for循环</font>

```基础for循环架构
for (初始化表达式; 循环条件; 迭代表达式) {
    // 循环体（需要重复执行的代码）
}
```

#### 执行逻辑：

1. **初始化表达式**：循环开始前执行一次（通常用于定义循环变量并赋初值，如 `int i = 0`）。
2. **循环条件**：每次执行循环体前判断。若条件为真（非 0），执行循环体；若为假（0），退出循环。
3. **迭代表达式**：每次循环体执行完毕后执行（通常用于更新循环变量，如 `i++`）。
4. 重复步骤 2 和 3，直到循环条件为假。

```完整实例代码（输出1到5
#include <stdio.h>
int main() {
    for (int i = 1; i <= 5; i++) {  // i从1开始，每次+1，直到i>5退出
        printf("%d ", i);  // 输出：1 2 3 4 5
    }
    return 0;
}
```

#### 适用场景：

* 已知循环次数（如遍历数组、固定次数的迭代）。
* 循环变量的初始化、判断、更新逻辑清晰（可在一行内体现）。

#### 注意：

* 三个表达式均可省略，但分号`;`必须保留。例如：`for (;;)` 是无限循环（需用`break`手动退出）。
* 初始化表达式中定义的变量（如`int i`）作用域仅限循环体内（C99 及以上标准支持）。

### 二、`while`循环 ——“条件优先” 的循环

### <font style="color:rgb(138, 208, 538);">2.while循环</font>

```基础while循环架构
while (循环条件) {
    // 循环体
}
```

#### 执行逻辑：

1. 先判断**循环条件**：若为真（非 0），执行循环体；若为假（0），直接退出循环。
2. 循环体执行完毕后，再次回到步骤 1 判断条件，重复执行。

```计算1-100的和
#include<stdio.h>
int main()
{
    int sum = 0;
    int i = 1;
    while(i<=100)
    {
    sum+=1;
    i++;
    }
    printf("sum=d%",sum);
    return 0;
}
```

#### 适用场景：

* 需要 “至少执行一次” 的场景（如用户输入验证、菜单选择等）。
* 循环条件依赖循环体的执行结果（如先输入再判断是否合法）。

#### 注意：

* 循环体**必定执行一次**，即使循环条件一开始就为假。
* 语法末尾的分号`;`不可省略（容易遗漏）。

### <font style="color:rgb(138, 208, 538);">3.do-while循环(先执行后判断)</font>

```基本do-while格式
do {
    // 循环体
} while (循环条件);  // 注意末尾有分号
```

#### 执行逻辑：

1. 先执行一次**循环体**（无论条件是否成立，至少执行一次）。
2. 执行完毕后，判断**循环条件**：若为真（非 0），回到步骤 1 重复执行；若为假（为0），退出循环。

```直到输入正确的数字才停止
#include <stdio.h>
int main() {
    int num;
    do {
        printf("请输入1~10的数字：");
        scanf("%d", &num);  // 先执行一次输入
    } while (num < 1 || num > 10);  // 若输入不合法，重复循环
    printf("你输入了正确的数字：%d", num);
    return 0;
}
```

### <font style="color:rgb(538, 38, 38);">杂项：从汇编语言的角度看i++与++i的区别</font>

一：前置自增++i（c语言就不再做演示了）

c语言

汇编1

```汇编
# 初始化i=0：将立即数0存入i的地址（假设i在ebp-4处）
movl    $0, -4(%ebp)      

# 前置自增++i的核心步骤：
movl    -4(%ebp), %eax    # 1. 将i的当前值（0）读到寄存器eax
addl    $1, %eax          # 2. 对eax自增1（eax=1）
movl    %eax, -4(%ebp)    # 3. 将自增后的值（1）写回i的内存（i=1）
movl    -4(%ebp), %eax    # 4. 读取自增后的i（1）到eax
movl    %eax, -8(%ebp)    # 5. 将eax的值（1）赋给a（a=1）i从0→1）
```

二：后置自增i++

汇编2

```汇编
# 初始化i=0：同前置自增
movl    $0, -4(%ebp)      

# 后置自增i++的核心步骤：
movl    -4(%ebp), %eax    # 1. 将i的当前值（0）读到eax（先保存原始值）
movl    %eax, -8(%ebp)    # 2. 将原始值（0）直接赋给b（b=0）
addl    $1, -4(%ebp)      # 3. 对i的内存直接自增1（i从0→1）
```

（为了看的清楚，汇编的解释放在末尾）

解释完所需的汇编语言后回归到本身的问题——“在汇编中i++和++i的区别”

可从汇编中看出 在进行++i时<font style="color:rgb(538, 38, 38);">自增操作</font>（步骤 2、3）先于<font style="color:rgb(538, 38, 38);">赋值操作</font>（步骤 4、5），因此 `a` 拿到的是自增后的值。

而在进行i++时 <font style="color:rgb(538, 38, 38);">赋值操作</font>（步骤 1、2）先于<font style="color:rgb(538, 38, 38);">自增操作</font>（步骤 3），因此 `b` 拿到的是自增前的原始值。

故有此可得出 int a =++i是先i+=1后赋值给a  而int a =i++是先赋值给a在i自身加1。

汇编主要由 指令 和 存储区 两方面来执行

指令(暂时只考虑对i++和++i的）：

### mov（等于，赋值操作，将后面存储区的数值赋值给前面的存储区）

- mov1 赋值数，被赋值

- mov1    ax     ,       bx        ----bx=ax

```
movl $10, %eax        ; 立即数10 → 寄存器eax（$表示立即数）
movl %eax, %ebx       ; 寄存器eax的值 → 寄存器ebx
movl %eax, -4(%ebp)   ; 寄存器eax的值 → 内存地址（ebp-4，即栈上变量）
movl -4(%ebp), %ecx   ; 内存地址（ebp-4）的值 → 寄存器ecx
```

### add/sub   (加法/减法，运算操作，将前面一个存储区的数加（减）到后面一个存储区的数上)

* `addl 源, 目的`：目的 = 目的 + 源
* `subl 源, 目的`：目的 = 目的 - 源

```加/减法
movl $5, %eax
addl $3, %eax   ; eax = 5 + 3 = 8
subl $2, %eax   ; eax = 8 - 2 = 6
```


