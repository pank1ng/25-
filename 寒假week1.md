# <font style="color:rgb(38, 218, 38);">完成事项</font>



### 汇编程序可分为3个段：

- data段

- bss段

- text段



# data段

段被用于声明初始化的数据或常数。此数据在运行时不会更改。您可以在段中声明各种常量值，文件名或缓冲区大小等。

    section.data     ; data 段声明数据段的语法

# bss 段

在 **bss** 段用于声明变量

    section.bss    ; 声明 bss 段的语法

# text 段

**text** 段被用于保持实际的代码。该段必须以全局声明 `_start` 开头，该声明告诉内核程序从何处开始执行

    section.text
       global _start
    _start:           

### 注释

汇编语言注释以分号（`;`）开头。它可以包含任何可打印字符，包括空格。

    add eax, ebx     ; 加上 ebx 到 eax



# 关于汇编语言声明

汇编语言程序包含 **3** 种类型的语句：

- **可执行指令** 或 简单的 **指令** 告诉处理器做什么。每个指令由一个 **操作码**（opcode）组成。每个可执行指令生成一个机器语言指令

- **汇编指令** 或 **伪操作** 告诉汇编器关于程序的各个方面。这些是不可执行的，不会生成机器语言指令

- **洪**，宏基本上是一种代码替换机制

# 汇编语言语句的语法

汇编语言语的每个语句遵循以下格式

    [label]   mnemonic   [operands]   [;comment]

方括号中的字段是可选的

基本指令包括两段：

- 第一段是要执行的指令（或助记符）的名称

- 第二段是命令的操作数或参数。

    INC COUNT        ; 增加内存变量 COUNT
    
    MOV TOTAL, 48    ; 将值 48 转移到
                     ; 内存变量 TOTAL
    
    ADD AH, BH       ; 添加寄存器 BH 内容
                     ; 到 AH 寄存器
    
    AND MASK1, 128   ; 对变量 MASK1 和 128
                     ; 执行 AND 操作
    
    ADD MARKS, 10    ; 将 10 加到变量 MARKS
    
    MOV AL, 10       ; 将值 10 传送到 AL 寄存器

    指令 寄存器，数值（寄存器中的内容）



##### 汇编语言代码在屏幕上显示 "Hello World"

    section    .text
       global _start     ;必须为链接器(ld)声明
    _start:                ;告诉链接器入口点
       mov    edx,len     ;消息长度
       mov    ecx,msg     ;写消息
       mov    ebx,1       ;文件描述符 (stdout)
       mov    eax,4       ;系统调用号 (sys_write)
       int    0x80        ;调用内核
       mov    eax,1       ;系统调用号 (sys_exit)
       int    0x80        ;调用内核
    section    .data
    msg db 'Hello, world!', 0xa  ;要打印的字符串
    len equ $ - msg     ;字符串的长度

### 关于上段函数的解释

### 1. 定义代码段

    section    .text

* `.text` 段包含程序的可执行代码

* 相当于 C 语言中的函数代码部分

* 这个段在内存中是只读的

### 2. 声明全局入口点

    global _start

* `global` 指令告诉链接器 `_start` 是一个全局符号

* 链接器（ld）需要知道程序的入口点

* 在 C 语言中，这个角色由 `main` 函数扮演

### 3. 定义入口点标签

    _start:

* 定义了一个标签 `_start`，这是程序的开始执行位置

* 当程序加载到内存时，CPU 从这里开始执行指令

* 在 C 语言中相当于 `int main() {`

### 4. 准备系统调用参数

    mov edx, len     ; 第三个参数：字符串长度

* 将数据段中定义的 `len` 值加载到 `edx` 寄存器

* 在 Linux 系统调用中，`edx` 存放第三个参数

* `len` 是在数据段定义的一个常量，等于字符串长度

    mov ecx, msg     ; 第二个参数：字符串地址

* 将 `msg` 的地址加载到 `ecx` 寄存器

* `msg` 是数据段中字符串的起始地址

* `ecx` 存放系统调用的第二个参数

    mov eax, 4       ; 系统调用号

* 将数值 `4` 加载到 `eax` 寄存器

* `4` 是 Linux 系统调用号，对应 `sys_write`

* 总而言之就是向文件描述符写入数

* 关于系统调用号：在高效和方便的同时还能做到标准化和提高稳定性，通过数字代替代码，类似于等效替代

### 5. 执行系统调用

    int 0x80         ; 软中断，调用内核

* `int 0x80` 触发软中断 0x80

* CPU 切换到内核模式，执行系统调用

* 内核根据 `eax` 的值（4=sys_write）执行写操作

* 参数从 `ebx`、`ecx`、`edx` 寄存器读取

此时的效果相当于执行了：

    write(1, msg, len);  // 向屏幕打印字符串

关于*软中断*  和 *硬件中断*  ：

硬件中断（硬中断）                                          软中断（软中断）
    外部事件触发                                                   软件指令触发

键盘按下 → CPU中断                                     int 0x80 → CPU中断
定时器到期 → CPU中断                                 int 0x10 → CPU中断
网卡收到数据 → CPU中断                             int 0x13 → CPU中断

### 6. 准备退出程序

    mov eax, 1       ; 系统调用号 (sys_exit)

* 将数值 `1` 加载到 `eax` 寄存器

* `1` 是系统调用号，对应 `sys_exit`

* 即：结束当前进程

### 7. 执行退出系统调用

    int 0x80         ; 调用内核

* 再次触发软中断 0x80

* 内核执行 `sys_exit` 系统调用

* 程序结束，控制权返回给操作系统

**此时的效果相当于：**

    exit(0);  // 退出程序，返回码为0（默认）

### 8. 定义数据段

    section .data

* `.data` 段包含已初始化的全局和静态变量

* 这个段在内存中是可读写的

* 程序启动时，这部分数据会被加载到内存

### 9. 定义字符串数据

    msg db 'Hello, world!', 0xa

* `msg:` 是一个标签，指向数据的起始位置

* `db` 表示 "define bytes"，即定义字节数据

* `'Hello, world!'` 是要存储的字符串

* `0xa` 是换行符的 ASCII 码（十六进制 0xA = 十进制 10 = '\n'）

* 总共定义了 14 个字节：13个字符 + 1个换行符

### 10. 计算字符串长度

    len equ $ - msg

* `len` 是一个符号（常量）

* `equ` 表示 "equate"，即定义符号常量

* `$` 代表当前地址（紧跟在字符串后面的位置）

* `msg` 是字符串起始地址

* `$ - msg` 计算字符串的字节数

* 结果：14（13个字符 + 1个换行符）



# 初步了解了一点点的go和rust

这种没看多少最近在打工带着看看

# <font style="color:rgb(38, 38, 38);">下周待做事项</font>

+ 
  
  # <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>

# <font style="color:rgb(38, 38, 38);">本周学习总结</font>

# <font style="color:rgb(38, 38, 38);">杂项</font>
